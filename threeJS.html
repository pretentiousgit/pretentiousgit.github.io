<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Model Loader with Enhanced View Cube</title>
    <style>
        :root {
            --primary-bg: #000;
            --panel-bg: rgba(0,0,0,0.7);
            --text-color: white;
            --accent-color: #4a9eff;
            --border-radius: 0.5rem;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: var(--primary-bg);
            font-family: Arial, sans-serif;
        }
        
        #info {
            position: absolute;
            top: 1rem;
            left: 1rem;
            color: var(--text-color);
            z-index: 100;
            background: var(--panel-bg);
            padding: 1rem;
            border-radius: var(--border-radius);
            max-width: 20rem;
        }
        
        #fileInput {
            margin: 1rem 0;
            color: var(--text-color);
        }
        
        #loadingIndicator {
            color: var(--accent-color);
            margin-top: 1rem;
        }
        
        .hidden {
            display: none;
        }
        
        canvas {
            display: block;
        }
        
        /* Enhanced View Cube Styles */
        #viewCubeContainer {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 5rem;
            height: 5rem;
            z-index: 200;
        }
        
        #viewCube {
            width: 5rem;
            height: 5rem;
            perspective: 30rem;
            position: relative;
        }
        
        .cube {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            cursor: grab;
            transition: transform 0.1s ease;
            user-select: none;
        }
        
        .cube:active {
            cursor: grabbing;
        }
        
        .cube.dragging {
            transition: none;
        }
        
        .cube-face {
            position: absolute;
            width: 5rem;
            height: 5rem;
            background: var(--panel-bg);
            border: 0.125rem solid rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-color);
            font-weight: bold;
            font-size: 0.7rem;
            transition: all 0.2s ease;
            backdrop-filter: blur(0.625rem);
            clip-path: polygon(15% 0%, 85% 0%, 100% 15%, 100% 85%, 85% 100%, 15% 100%, 0% 85%, 0% 15%);
            pointer-events: none;
        }
        
        .cube-face:hover {
            background: rgba(74, 158, 255, 0.3);
            border-color: var(--accent-color);
            transform: scale(1.05);
        }
        
        .cube-face.front { transform: rotateY(0deg) translateZ(2.5rem); }
        .cube-face.back { transform: rotateY(180deg) translateZ(2.5rem); }
        .cube-face.right { transform: rotateY(90deg) translateZ(2.5rem); }
        .cube-face.left { transform: rotateY(-90deg) translateZ(2.5rem); }
        .cube-face.top { transform: rotateX(90deg) translateZ(2.5rem); }
        .cube-face.bottom { transform: rotateX(-90deg) translateZ(2.5rem); }
        
        /* Corner controls for isometric views */
        .cube-corner {
            position: absolute;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer;
            transition: all 0.2s ease;
            width: 0.8rem;
            height: 0.8rem;
            clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
            pointer-events: auto;
        }
        
        .cube-corner:hover {
            background: rgba(74, 158, 255, 0.4);
            border-color: var(--accent-color);
        }
        
        /* Position corners */
        .corner-tlf { top: 0; left: 0; transform: translate(-50%, -50%); }
        .corner-trf { top: 0; right: 0; transform: translate(50%, -50%); }
        .corner-blf { bottom: 0; left: 0; transform: translate(-50%, 50%); }
        .corner-brf { bottom: 0; right: 0; transform: translate(50%, 50%); }
        
        /* Animation controls */
        #animationControls {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            background: var(--panel-bg);
            padding: 1rem;
            border-radius: var(--border-radius);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .controls-row {
            display: flex;
            gap: 0.25rem;
            align-items: center;
        }
        
        .control-button {
            background: rgba(74, 158, 255, 0.2);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        
        .control-button:hover {
            background: rgba(74, 158, 255, 0.4);
        }
        
        .control-button.active {
            background: var(--accent-color);
        }
        
        /* View navigation arrows */
        .view-arrow {
            background: rgba(74, 158, 255, 0.2);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .view-arrow:hover {
            background: rgba(74, 158, 255, 0.4);
            transform: scale(1.1);
        }
        
        .view-arrow:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>Three.js Model Loader</h3>
        <input type="file" id="fileInput" accept=".stl" />
        <button id="loadSample">Load Sample</button>
        <div id="loadingIndicator" class="hidden">Loading model...</div>
        <div id="error" class="hidden" style="color: red; margin-top: 1rem;"></div>
        
        <div id="debugControls" style="margin-top: 1rem; border-top: 1px solid #444; padding-top: 1rem;">
            <h4 style="margin: 0.5rem 0;">Model Transform</h4>
            
            <div style="margin: 0.5rem 0;">
                <label>Position X: </label>
                <input type="number" id="posX" value="0" step="0.1" style="width: 3.75rem;">
                <label style="margin-left: 0.625rem;">Y: </label>
                <input type="number" id="posY" value="0" step="0.1" style="width: 3.75rem;">
                <label style="margin-left: 0.625rem;">Z: </label>
                <input type="number" id="posZ" value="0" step="0.1" style="width: 3.75rem;">
            </div>
            
            <div style="margin: 0.5rem 0;">
                <label>Rotation X: </label>
                <input type="number" id="rotX" value="0" step="15" style="width: 3.75rem;">
                <label style="margin-left: 0.625rem;">Y: </label>
                <input type="number" id="rotY" value="0" step="15" style="width: 3.75rem;">
                <label style="margin-left: 0.625rem;">Z: </label>
                <input type="number" id="rotZ" value="0" step="15" style="width: 3.75rem;">°
            </div>
            
            <div style="margin: 0.5rem 0;">
                <label>Scale: </label>
                <input type="number" id="scale" value="1" step="0.1" min="0.1" style="width: 3.75rem;">
                <button id="resetModel" style="margin-left: 0.625rem;">Reset</button>
                <button id="autoOrient" style="margin-left: 0.25rem;">Auto Orient</button>
            </div>
            
            <div style="margin: 0.5rem 0; font-size: 0.75rem; color: #ccc;">
                <div id="modelStats">No model loaded</div>
            </div>

            <button id="exportSTL" style="margin-left: 0.25rem;">Export STL</button>
        </div>
    </div>

    <!-- Enhanced View Cube Control -->
    <div id="viewCubeContainer">
        <div id="viewCube">
            <div class="cube" id="cube">
                <div class="cube-face front" data-view="front">FRONT</div>
                <div class="cube-face back" data-view="back">BACK</div>
                <div class="cube-face right" data-view="right">RIGHT</div>
                <div class="cube-face left" data-view="left">LEFT</div>
                <div class="cube-face top" data-view="top">TOP</div>
                <div class="cube-face bottom" data-view="bottom">BOTTOM</div>
                
                <!-- Corner controls for isometric views -->
                <div class="cube-corner corner-tlf" data-view="iso1" title="Top-Left-Front Isometric"></div>
                <div class="cube-corner corner-trf" data-view="iso2" title="Top-Right-Front Isometric"></div>
                <div class="cube-corner corner-blf" data-view="iso3" title="Bottom-Left-Front Isometric"></div>
                <div class="cube-corner corner-brf" data-view="iso4" title="Bottom-Right-Front Isometric"></div>
            </div>
        </div>
    </div>

    <!-- Animation Controls with Navigation -->
    <div id="animationControls">
        <h4 style="margin: 0 0 0.5rem 0; color: var(--text-color);">Camera</h4>
        <div class="controls-row">
            <button class="control-button" id="autoRotate">Auto Rotate</button>
            <button class="control-button" id="homeView">Home</button>
        </div>
        <div class="controls-row">
            <div class="view-arrow" id="prevView" title="Previous view">‹</div>
            <div class="view-arrow" id="nextView" title="Next view">›</div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.166.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.166.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { STLExporter } from 'three/addons/exporters/STLExporter.js';
        
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x222222);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xFFFFFF, 1);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(1, 1, 1);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xffffff, 0.8, 100);
        pointLight.position.set(2, 3, 2);
        pointLight.castShadow = true;
        scene.add(pointLight);

        const pointLight2 = new THREE.PointLight(0xffffff, 0.5, 100);
        pointLight2.position.set(-2, 2, -2);
        scene.add(pointLight2);

        // Enhanced camera animation system with view cube sync and drag controls
        let cameraTarget = { x: 0, y: 2, z: 5 };
        let autoRotateEnabled = false;
        let autoRotateSpeed = 0.005;
        let currentViewIndex = 0;
        
        // Drag control variables
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let cubeRotationX = 0;
        let cubeRotationY = 0;
        let dragSensitivity = 0.5;

        const cameraViews = {
            front: { x: 0, y: 0, z: 5 },
            back: { x: 0, y: 0, z: -5 },
            right: { x: 5, y: 0, z: 0 },
            left: { x: -5, y: 0, z: 0 },
            top: { x: 0, y: 5, z: 0 },
            bottom: { x: 0, y: -5, z: 0 },
            iso1: { x: -3, y: 3, z: 3 },   // Top-Left-Front
            iso2: { x: 3, y: 3, z: 3 },    // Top-Right-Front
            iso3: { x: -3, y: -3, z: 3 },  // Bottom-Left-Front
            iso4: { x: 3, y: -3, z: 3 },   // Bottom-Right-Front
            home: { x: 2, y: 2, z: 5 }
        };

        // View sequence for arrow navigation (main 6 faces)
        const viewSequence = ['front', 'right', 'back', 'left', 'top', 'bottom'];

        function updateViewCubeOrientation(rotX = null, rotY = null) {
            const cube = document.getElementById('cube');
            
            if (rotX !== null && rotY !== null) {
                // Direct rotation from drag
                cube.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;
            } else {
                // Calculate camera's spherical coordinates relative to origin
                const cameraPos = camera.position.clone().normalize();
                
                // Convert camera position to rotation angles
                const phi = Math.acos(cameraPos.y); // polar angle
                const theta = Math.atan2(cameraPos.z, cameraPos.x); // azimuthal angle
                
                // Convert to degrees and apply to cube
                const rotYDeg = -theta * 180 / Math.PI;
                const rotXDeg = (phi - Math.PI/2) * 180 / Math.PI;
                
                cubeRotationX = rotXDeg;
                cubeRotationY = rotYDeg;
                
                cube.style.transform = `rotateX(${rotXDeg}deg) rotateY(${rotYDeg}deg)`;
            }
        }

        function updateCameraFromCube(rotX, rotY) {
            // Convert cube rotation back to camera position
            const phi = (rotX * Math.PI / 180) + Math.PI/2; // polar angle
            const theta = -rotY * Math.PI / 180; // azimuthal angle
            
            // Calculate camera position at fixed distance
            const radius = 5;
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            
            camera.position.set(x, y, z);
            camera.lookAt(0, 0, 0);
            cameraTarget = { x, y, z };
        }

        function animateCameraTo(targetPos, duration = 1000, updateCube = true) {
            const startPos = { 
                x: camera.position.x, 
                y: camera.position.y, 
                z: camera.position.z 
            };
            
            const startTime = Date.now();
            
            function updateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Smooth easing function
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                camera.position.x = startPos.x + (targetPos.x - startPos.x) * easeProgress;
                camera.position.y = startPos.y + (targetPos.y - startPos.y) * easeProgress;
                camera.position.z = startPos.z + (targetPos.z - startPos.z) * easeProgress;
                
                camera.lookAt(0, 0, 0);
                
                if (updateCube && !isDragging) {
                    if (updateCube && !isDragging) {
                    updateViewCubeOrientation();
                }
                }
                
                if (progress < 1) {
                    requestAnimationFrame(updateCamera);
                } else {
                    cameraTarget = { ...targetPos };
                    if (updateCube) {
                        // Update stored cube rotations after animation
                        updateViewCubeOrientation();
                    }
                }
            }
            
            autoRotateEnabled = false;
            document.getElementById('autoRotate').classList.remove('active');
            updateCamera();
        }

        function goToView(viewName) {
            if (cameraViews[viewName]) {
                animateCameraTo(cameraViews[viewName]);
                
                // Update current view index if it's in the sequence
                const index = viewSequence.indexOf(viewName);
                if (index !== -1) {
                    currentViewIndex = index;
                }
            }
        }

        function goToNextView() {
            currentViewIndex = (currentViewIndex + 1) % viewSequence.length;
            const viewName = viewSequence[currentViewIndex];
            goToView(viewName);
        }

        function goToPrevView() {
            currentViewIndex = (currentViewIndex - 1 + viewSequence.length) % viewSequence.length;
            const viewName = viewSequence[currentViewIndex];
            goToView(viewName);
        }

        // View cube drag controls
        const cube = document.getElementById('cube');
        
        cube.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('cube-corner')) return; // Don't interfere with corner clicks
            
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            
            cube.classList.add('dragging');
            autoRotateEnabled = false;
            document.getElementById('autoRotate').classList.remove('active');
            
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;
            
            const newRotY = cubeRotationY + deltaX * dragSensitivity;
            const newRotX = cubeRotationX - deltaY * dragSensitivity;
            
            // Clamp X rotation to reasonable bounds
            const clampedRotX = Math.max(-90, Math.min(90, newRotX));
            
            updateViewCubeOrientation(clampedRotX, newRotY);
            updateCameraFromCube(clampedRotX, newRotY);
            
            e.preventDefault();
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                cube.classList.remove('dragging');
                
                // Update stored rotation values
                const deltaX = event.clientX - dragStartX;
                const deltaY = event.clientY - dragStartY;
                
                cubeRotationY += deltaX * dragSensitivity;
                cubeRotationX -= deltaY * dragSensitivity;
                cubeRotationX = Math.max(-90, Math.min(90, cubeRotationX));
            }
        });

        // View cube click controls (for face/corner clicks)
        document.getElementById('viewCube').addEventListener('click', (event) => {
            // Only handle clicks if we weren't dragging
            if (event.target.classList.contains('cube-corner') || event.target.classList.contains('cube-face')) {
                const viewType = event.target.dataset.view;
                if (viewType) {
                    goToView(viewType);
                }
            }
        });

        // Arrow navigation
        document.getElementById('nextView').addEventListener('click', goToNextView);
        document.getElementById('prevView').addEventListener('click', goToPrevView);

        // Animation controls
        document.getElementById('autoRotate').addEventListener('click', () => {
            autoRotateEnabled = !autoRotateEnabled;
            document.getElementById('autoRotate').classList.toggle('active', autoRotateEnabled);
        });

        document.getElementById('homeView').addEventListener('click', () => {
            goToView('home');
        });

        // Set initial camera position
        camera.position.set(2, 2, 5);
        camera.lookAt(0, 0, 0);
        cameraTarget = { x: 2, y: 2, z: 5 };

        // Model loading system (same as before)
        let currentModel = null;
        const loader = new STLLoader();
        const exporter = new STLExporter();

        function updateModelStats() {
            const statsDiv = document.getElementById('modelStats');
            if (currentModel) {
                const pos = currentModel.position;
                const rot = currentModel.rotation;
                const scale = currentModel.scale.x;
                statsDiv.innerHTML = `Pos: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})<br>
                                     Rot: (${(rot.x * 180/Math.PI).toFixed(0)}°, ${(rot.y * 180/Math.PI).toFixed(0)}°, ${(rot.z * 180/Math.PI).toFixed(0)}°)<br>
                                     Scale: ${scale.toFixed(2)}`;
            } else {
                statsDiv.textContent = 'No model loaded';
            }
        }

        function updateModelTransform() {
            if (!currentModel) return;
            
            const posX = parseFloat(document.getElementById('posX').value) || 0;
            const posY = parseFloat(document.getElementById('posY').value) || 0;
            const posZ = parseFloat(document.getElementById('posZ').value) || 0;
            
            const rotX = (parseFloat(document.getElementById('rotX').value) || 0) * Math.PI / 180;
            const rotY = (parseFloat(document.getElementById('rotY').value) || 0) * Math.PI / 180;
            const rotZ = (parseFloat(document.getElementById('rotZ').value) || 0) * Math.PI / 180;
            
            const scale = parseFloat(document.getElementById('scale').value) || 1;
            
            currentModel.position.set(posX, posY, posZ);
            currentModel.rotation.set(rotX, rotY, rotZ);
            currentModel.scale.setScalar(scale);
            
            updateModelStats();
        }

        function updateDebugControls() {
            if (!currentModel) return;
            
            document.getElementById('posX').value = currentModel.position.x.toFixed(2);
            document.getElementById('posY').value = currentModel.position.y.toFixed(2);
            document.getElementById('posZ').value = currentModel.position.z.toFixed(2);
            
            document.getElementById('rotX').value = (currentModel.rotation.x * 180 / Math.PI).toFixed(0);
            document.getElementById('rotY').value = (currentModel.rotation.y * 180 / Math.PI).toFixed(0);
            document.getElementById('rotZ').value = (currentModel.rotation.z * 180 / Math.PI).toFixed(0);
            
            document.getElementById('scale').value = currentModel.scale.x.toFixed(2);
            
            updateModelStats();
        }

        function showLoading() {
            document.getElementById('loadingIndicator').classList.remove('hidden');
            document.getElementById('error').classList.add('hidden');
        }

        function hideLoading() {
            document.getElementById('loadingIndicator').classList.add('hidden');
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
            hideLoading();
        }

        function clearScene() {
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }
        }

        function autoOrientModel(object) {
            const box = new THREE.Box3().setFromObject(object);
            const size = box.getSize(new THREE.Vector3());
            
            const dimensions = [
                { axis: 'x', size: size.x },
                { axis: 'y', size: size.y },
                { axis: 'z', size: size.z }
            ];
            
            dimensions.sort((a, b) => a.size - b.size);
            const shortestAxis = dimensions[0].axis;
            
            if (shortestAxis === 'x') {
                object.rotation.z = Math.PI / 2;
            } else if (shortestAxis === 'z') {
                object.rotation.x = -Math.PI / 2;
            }
            
            const aspectRatioXZ = Math.max(size.x, size.z) / Math.min(size.x, size.z);
            const heightRatio = size.y / Math.max(size.x, size.z);
            
            if (heightRatio < 0.3 && aspectRatioXZ > 2) {
                if (size.x > size.z) {
                    object.rotation.z = Math.PI / 2;
                } else {
                    object.rotation.x = -Math.PI / 2;
                }
            }
        }

        function centerAndScaleModel(object) {
            autoOrientModel(object);
            
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            object.position.set(-center.x, -center.y, -center.z);
            
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim > 0) {
                const scale = 2 / maxDim;
                const finalScale = Math.min(scale, 10);
                object.scale.setScalar(finalScale);
            }
        }

        function loadModel(url) {
            showLoading();
            clearScene();

            loader.load(
                url,
                function (geometry) {
                    hideLoading();
                    
                    const material = new THREE.MeshPhongMaterial({ 
                        color: 0xffffff,
                        shininess: 100,
                        side: THREE.DoubleSide
                    });
                    
                    currentModel = new THREE.Mesh(geometry, material);
                    currentModel.castShadow = true;
                    currentModel.receiveShadow = true;
                    
                    geometry.deleteAttribute('normal');
                    geometry.computeVertexNormals();
                    geometry.computeBoundingSphere();

                    centerAndScaleModel(currentModel);
                    scene.add(currentModel);
                    updateDebugControls();
                },
                function (progress) {
                    console.log('Loading progress:', progress);
                },
                function (error) {
                    console.error('Loading error:', error);
                    showError('Failed to load STL model: ' + error.message);
                }
            );
        }

        // Event listeners
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                loadModel(url);
            }
        });

        document.getElementById('posX').addEventListener('input', updateModelTransform);
        document.getElementById('posY').addEventListener('input', updateModelTransform);
        document.getElementById('posZ').addEventListener('input', updateModelTransform);
        document.getElementById('rotX').addEventListener('input', updateModelTransform);
        document.getElementById('rotY').addEventListener('input', updateModelTransform);
        document.getElementById('rotZ').addEventListener('input', updateModelTransform);
        document.getElementById('scale').addEventListener('input', updateModelTransform);
        
        document.getElementById('resetModel').addEventListener('click', function() {
            if (currentModel) {
                centerAndScaleModel(currentModel);
                updateDebugControls();
            }
        });

        document.getElementById('autoOrient').addEventListener('click', function() {
            if (currentModel) {
                currentModel.rotation.set(0, 0, 0);
                autoOrientModel(currentModel);
                updateDebugControls();
            }
        });

        document.getElementById('loadSample').addEventListener('click', function() {
            const sampleUrl = 'https://threejs.org/examples/models/stl/ascii/slotted_disk.stl';
            loadModel(sampleUrl);
        });

        document.getElementById('exportSTL').addEventListener('click', function() {
            if (!currentModel) return;
            
            const clonedModel = currentModel.clone();
            clonedModel.updateMatrixWorld();
            
            const geometry = clonedModel.geometry.clone();
            geometry.applyMatrix4(clonedModel.matrixWorld);
            
            const stlData = exporter.parse(clonedModel, { binary: true });
            
            const blob = new Blob([stlData], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'reoriented_model.stl';
            link.click();
            URL.revokeObjectURL(url);
        });

        // Ground plane
        const groundGeometry = new THREE.PlaneGeometry(6, 6);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1;
        ground.receiveShadow = true;
        scene.add(ground);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Auto rotation around the model
            if (autoRotateEnabled) {
                const radius = Math.sqrt(cameraTarget.x * cameraTarget.x + cameraTarget.z * cameraTarget.z);
                const angle = Math.atan2(cameraTarget.z, cameraTarget.x) + autoRotateSpeed;
                
                cameraTarget.x = Math.cos(angle) * radius;
                cameraTarget.z = Math.sin(angle) * radius;
                
                camera.position.x = cameraTarget.x;
                camera.position.z = cameraTarget.z;
                camera.lookAt(0, 0, 0);
                
                updateViewCubeOrientation();
            }
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize view cube orientation
        updateViewCubeOrientation();

        // Start animation
        animate();

        // Load default model
        loadModel('https://threejs.org/examples/models/stl/ascii/slotted_disk.stl');
    </script>
</body>
</html>